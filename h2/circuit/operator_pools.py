import openfermion
import numpy as np
import copy as cp
import re
import scipy
from openfermion.linalg import get_sparse_operator
import random
import math

from openfermion import *

# description:
# singlet_SD and singlet_GSD are fermionic pools with singlet_GSD being the generalized version

# commutator_generated is minimal complete pool (MCP) generated by bruteful searching

# v and g are the MCPs in the qubit adapt paper, vx is v pool modifed by replacing Z with XX

# QE is qubit excitation from the crispin paper

# qubits are customized qubit pool

# GSD_extract is the qubit generated from singlet_GSD and removing the Z string, which is the one used in qubit-adapt paper
def parity(fermion_operator, n_modes):
    return openfermion.binary_code_transform(fermion_operator, parity_code(n_modes))

class OperatorPool:
    def __init__(self):
        self.n_orb = 0
        self.n_occ_a = 0
        self.n_occ_b = 0
        self.n_vir_a = 0
        self.n_vir_b = 0

        self.n_spin_orb = 0

    def init(self,molecule):

        self.n_orb = molecule.n_orbitals
        # print(self.n_orb)
        # print(molecule.n_electrons)
        self.n_spin_orb = 2*self.n_orb
        self.n_occ_a = molecule.get_n_alpha_electrons()
        # print(self.n_occ_a)
        self.n_occ_b = molecule.get_n_beta_electrons()
        # print(self.n_occ_b)

        self.n_vir_a = self.n_orb - self.n_occ_a
        self.n_vir_b = self.n_orb - self.n_occ_b

        self.n_occ = self.n_occ_a
        self.n_vir = self.n_vir_a
        self.n_ops = 0

        self.num = 2*molecule.n_orbitals

        self.generate_SQ_Operators()

    def generate_SQ_Operators(self):
        print("Virtual: Reimplement")
        exit()

    def generate_SparseMatrix(self):
        self.spmat_ops = []
        print(" Generate Sparse Matrices for operators in pool")
        for op in self.fermi_ops:
            self.spmat_ops.append(get_sparse_operator(op, n_qubits = self.n_spin_orb))
        assert(len(self.spmat_ops) == self.n_ops)
        return

class singlet_SD_JW(OperatorPool):
    def generate_SQ_Operators(self):
        """
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet SD operators")
        self.fermi_ops = []

        n_occ = self.n_occ
        n_vir = self.n_vir

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                termA =  FermionOperator(((aa,1),(ia,0)), 1/np.sqrt(2))
                termA += FermionOperator(((ab,1),(ib,0)), 1/np.sqrt(2))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(openfermion.jordan_wigner(termA))


        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for j in range(i,n_occ):
                ja = 2*j
                jb = 2*j+1

                for a in range(0,n_vir):
                    aa = 2*n_occ + 2*a
                    ab = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        ba = 2*n_occ + 2*b
                        bb = 2*n_occ + 2*b+1

                        termA =  FermionOperator(((aa,1),(ba,1),(ia,0),(ja,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(bb,1),(ib,0),(jb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), 1/np.sqrt(12))

                        termB  = FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/2)
                        termB += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), -1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), -1/2)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0
                        coeffB = 0
                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t
                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t


                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(openfermion.jordan_wigner(termA))

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(openfermion.jordan_wigner(termB))

        self.n_ops = len(self.fermi_ops)
        print(" Number of operators: ", self.n_ops)
        return

class singlet_GSD_JW(OperatorPool):
    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                termA =  FermionOperator(((pa,1),(qa,0)))
                termA += FermionOperator(((pb,1),(qb,0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(openfermion.jordan_wigner(termA))


        pq = -1
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                pq += 1

                rs = -1
                for r in range(0,self.n_orb):
                    ra = 2*r
                    rb = 2*r+1

                    for s in range(r,self.n_orb):
                        sa = 2*s
                        sb = 2*s+1

                        rs += 1

                        if(pq > rs):
                            continue

                        termA =  FermionOperator(((ra,1),(pa,0),(sa,1),(qa,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pb,0),(sb,1),(qb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ra,1),(pa,0),(sb,1),(qb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pb,0),(sa,1),(qa,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ra,1),(pb,0),(sb,1),(qa,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pa,0),(sa,1),(qb,0)), 1/np.sqrt(12))

                        termB =  FermionOperator(((ra,1),(pa,0),(sb,1),(qb,0)),  1/2.0)
                        termB += FermionOperator(((rb,1),(pb,0),(sa,1),(qa,0)),  1/2.0)
                        termB += FermionOperator(((ra,1),(pb,0),(sb,1),(qa,0)), -1/2.0)
                        termB += FermionOperator(((rb,1),(pa,0),(sa,1),(qb,0)), -1/2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(openfermion.jordan_wigner(termA))

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(openfermion.jordan_wigner(termB))

        self.n_ops = len(self.fermi_ops)
        print(" Number of operators: ", self.n_ops)
        return

class v(OperatorPool):
    def generate_SQ_Operators(self):

        self.bin_pool = []
        self.fermi_ops = []

        ii = self.num

        self.n_spin_orb = ii

        first_picked = []
        Y0 = np.zeros((2 * ii)).tolist()
        Y0[0] = 1
        Y0[ii] = 1
        Y0 = [int(k) for k in Y0]
        first_picked.append(Y0)

        for i in range(1, ii):
            for j in first_picked:
                j[i] = int(1)
                j = [int(k) for k in j]

            Y = np.zeros((2 * ii)).tolist()
            Y[i] = int(1)
            Y[i+ii] = int(1)
            Y = [int(k) for k in Y]
            first_picked.append(Y)

            if i > 1:
                Y = np.zeros((2 * ii)).tolist()
                Y[i-1] = int(1)
                Y[i+ii-1] = int(1)
                Y = [int(k) for k in Y]
                first_picked.append(Y)

        picked = first_picked.copy()

        for i in range(len(picked)):
            pauli_string = ''
            for j in range(ii):
                if picked[i][j] == 0:
                    if picked[i][j + ii] == 1:
                        pauli_string += 'X%d ' % j
                if picked[i][j] == 1:
                    if picked[i][j + ii] == 0:
                        pauli_string += 'Z%d ' % j
                    else:
                        pauli_string += 'Y%d ' % j
            print(pauli_string)

        for i in range(len(first_picked)):
            pauli_string = ''
            for j in range(ii):
                if first_picked[i][j] == 0:
                    if first_picked[i][j + ii] == 1:
                        pauli_string += 'X%d ' % j
                if first_picked[i][j] == 1:
                    if first_picked[i][j + ii] == 0:
                        pauli_string += 'Z%d ' % j
                    else:
                        pauli_string += 'Y%d ' % j
            A = QubitOperator(pauli_string, 0+1j)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops) #Vlad's pool in qubit-adapt paper

class vx(OperatorPool):
    def generate_SQ_Operators(self):

        self.bin_pool = []
        self.fermi_ops = []

        ii = self.num

        self.n_spin_orb = ii

        first_picked = []
        Y0 = np.zeros((2 * ii)).tolist()
        Y0[0] = 1
        Y0[ii] = 1
        Y0 = [int(k) for k in Y0]
        first_picked.append(Y0)

        for i in range(1, ii):
            for j in first_picked:
                j[i+ii] = int(1)
                j = [int(k) for k in j]

            Y = np.zeros((2 * ii)).tolist()
            Y[i] = int(1)
            Y[i+ii] = int(1)
            Y = [int(k) for k in Y]
            first_picked.append(Y)

            if i > 1:
                Y = np.zeros((2 * ii)).tolist()
                Y[i-1] = int(1)
                Y[i+ii-1] = int(1)
                Y = [int(k) for k in Y]
                first_picked.append(Y)

        picked = first_picked.copy()

        for i in range(len(picked)):
            pauli_string = ''
            for j in range(ii):
                if picked[i][j] == 0:
                    if picked[i][j + ii] == 1:
                        pauli_string += 'X%d ' % j
                if picked[i][j] == 1:
                    if picked[i][j + ii] == 0:
                        pauli_string += 'Z%d ' % j
                    else:
                        pauli_string += 'Y%d ' % j
            print(pauli_string)

        for i in range(len(first_picked)):
            pauli_string = ''
            for j in range(ii):
                if first_picked[i][j] == 0:
                    if first_picked[i][j + ii] == 1:
                        pauli_string += 'X%d ' % j
                if first_picked[i][j] == 1:
                    if first_picked[i][j + ii] == 0:
                        pauli_string += 'Z%d ' % j
                    else:
                        pauli_string += 'Y%d ' % j
            A = QubitOperator(pauli_string, 0+1j)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops) #Vlad's pool with z replaced by x

class g(OperatorPool):
    def generate_SQ_Operators(self):

        self.bin_pool = []
        self.fermi_ops = []

        ii = self.num

        self.n_spin_orb = ii

        first_picked = []

        for i in range(ii-1):
            ZY = np.zeros((2 * ii)).tolist()
            ZY[i] = int(1)

            ZY[i+1] = int(1)
            ZY[i+ii+1] = int(1)

            ZY = [int(k) for k in ZY]
            first_picked.append(ZY)

            Y = np.zeros((2 * ii)).tolist()
            Y[i] = int(1)
            Y[i+ii] = int(1)
            Y = [int(k) for k in Y]
            first_picked.append(Y)

        picked = first_picked.copy()

        for i in range(len(picked)):
            pauli_string = ''
            for j in range(ii):
                if picked[i][j] == 0:
                    if picked[i][j + ii] == 1:
                        pauli_string += 'X%d ' % j
                if picked[i][j] == 1:
                    if picked[i][j + ii] == 0:
                        pauli_string += 'Z%d ' % j
                    else:
                        pauli_string += 'Y%d ' % j
            print(pauli_string)

        for i in range(len(first_picked)):
            pauli_string = ''
            for j in range(ii):
                if first_picked[i][j] == 0:
                    if first_picked[i][j + ii] == 1:
                        pauli_string += 'X%d ' % j
                if first_picked[i][j] == 1:
                    if first_picked[i][j + ii] == 0:
                        pauli_string += 'Z%d ' % j
                    else:
                        pauli_string += 'Y%d ' % j
            A = QubitOperator(pauli_string, 0+1j)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops) #George's pool with z replaced by x

class qubit_excitation_JW(OperatorPool):

    def norm(self, matrix):
        tr = (matrix.dot(matrix.transpose().conj())).diagonal().sum().real
        return tr

    def com(self, M1, M2):
        comm = M1.dot(M2)-M2.dot(M1)
        return comm

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi = []
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                termA =  FermionOperator(((pa,1),(qa,0)))
                termA -= hermitian_conjugated(termA)
                termA = normal_ordered(termA)
                if termA.many_body_order() > 0:
                    self.fermi.append(termA)

                termA = FermionOperator(((pb,1),(qb,0)))
                termA -= hermitian_conjugated(termA)
                termA = normal_ordered(termA)
                if termA.many_body_order() > 0:
                    self.fermi.append(termA)

        pq = -1
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                pq += 1

                rs = -1
                for r in range(0,self.n_orb):
                    ra = 2*r
                    rb = 2*r+1

                    for s in range(r,self.n_orb):
                        sa = 2*s
                        sb = 2*s+1

                        rs += 1

                        if(pq > rs):
                            continue

                        termA =  FermionOperator(((ra,1),(pa,0),(sa,1),(qa,0)))
                        termA -= hermitian_conjugated(termA)
                        termA = normal_ordered(termA)
                        if termA.many_body_order() > 0:
                            self.fermi.append(termA)

                        termA = FermionOperator(((rb,1),(pb,0),(sb,1),(qb,0)))
                        termA -= hermitian_conjugated(termA)
                        termA = normal_ordered(termA)
                        if termA.many_body_order() > 0:
                            self.fermi.append(termA)

                        termA = FermionOperator(((ra,1),(pa,0),(sb,1),(qb,0)))
                        termA -= hermitian_conjugated(termA)
                        termA = normal_ordered(termA)
                        if termA.many_body_order() > 0:
                            self.fermi.append(termA)

                        termA = FermionOperator(((rb,1),(pb,0),(sa,1),(qa,0)))
                        termA -= hermitian_conjugated(termA)
                        termA = normal_ordered(termA)
                        if termA.many_body_order() > 0:
                            self.fermi.append(termA)

                        termA = FermionOperator(((ra,1),(pb,0),(sb,1),(qa,0)))
                        termA -= hermitian_conjugated(termA)
                        termA = normal_ordered(termA)
                        if termA.many_body_order() > 0:
                            self.fermi.append(termA)

                        termA = FermionOperator(((rb,1),(pa,0),(sa,1),(qb,0)))
                        termA -= hermitian_conjugated(termA)
                        termA = normal_ordered(termA)
                        if termA.many_body_order() > 0:
                            self.fermi.append(termA)

        self.n_ops = len(self.fermi)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        self.fermi_ops = []

        for i in self.fermi:
            pauli = openfermion.transforms.jordan_wigner(i)
            op = QubitOperator('X0', 0)
            for line in pauli.terms:
                coeff = pauli.terms[line]
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

                pauli_string = ''
                flip = []
                for k in range(n):
                    if Bin[k] == 0:
                        if Bin[k + n] == 1:
                            pauli_string += 'X%d ' % k
                            flip.append(k)
                    if Bin[k] == 1:
                        if Bin[k + n] == 1:
                            pauli_string += 'Y%d ' % k
                            flip.append(k)
                flip.sort()
                z_string = list(range(flip[0] + 1,flip[1]))
                if len(flip) == 4:
                    for i in range(flip[2] + 1, flip[3]):
                        z_string.append(i)
                print("Z string:", z_string)
                for i in z_string:
                    Bin[i] += 1
                    Bin[i] = Bin[i] % 2
                for k in range(n):
                    if Bin[k] == 1:
                        if Bin[k + n] == 0:
                            pauli_string += 'Z%d ' % k
                A = QubitOperator(pauli_string, coeff)
                op += A

            print(op)
            self.fermi_ops.append(op)

        self.n_ops = len(self.fermi_ops)
        print(" Number of qubit excitation operators: ", self.n_ops)
        return

class qubit_excitation_half_JW(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")
        self.fermi_ops = []

        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p+1,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                    
                pstringa=""
                pstringa+="X%d " % qa
                pstringa+="Y%d" % pa
                
                pstringb=""
                pstringb+="X%d " % qb
                pstringb+="Y%d" % pb
                
                A=QubitOperator(pstringa, 0 + 1j )
                B=QubitOperator(pstringb, 0 + 1j)
                
                sqo=str(A)
                terms=sqo.splitlines()
                par=0
                for term in terms:
                    if len(re.findall('Y', term))%2==1:
                        par+=1
                        if par==len(terms):
                            if A not in self.fermi_ops:
                                self.fermi_ops.append(A)
                sqo=str(B)
                terms=sqo.splitlines()
                par=0
                for term in terms:
                    if len(re.findall('Y', term))%2==1:
                        par+=1
                if par==len(terms):
                    if B not in self.fermi_ops:
                        self.fermi_ops.append(B)
            
                


        pq = -1
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                pq += 1

                rs = -1
                for r in range(0,self.n_orb):
       
                    ra = 2*r
                    rb = 2*r+1

                    for s in range(r,self.n_orb):
                        sa = 2*s
                        sb = 2*s+1

                        rs += 1

                        if(pq > rs):
                            continue
                            
                        pstring1=''
                        pstring1+='X%d ' %ra 
                        pstring1+='X%d ' %pa
                        pstring1+='X%d ' %sa
                        pstring1+='Y%d' %qa
                        Q1=QubitOperator(pstring1, 0 + 1j)
                        pstring2=''
                        pstring2+='X%d ' %qa 
                        pstring2+='Y%d ' %ra
                        pstring2+='Y%d ' %pa
                        pstring2+='Y%d' %sa
                        Q2=QubitOperator(pstring2, 0 - 1j)

                        
                        A=Q1+Q2
                        
                        sqo=str(A)
                        terms=sqo.splitlines()
                        par=0
                        for term in terms:
                            if len(re.findall('Y', term))%2==1:
                                par+=1
                        if par==len(terms):
                            if A not in self.fermi_ops:
                                self.fermi_ops.append(A)
                                
                                
                        pstring1=''
                        pstring1+='X%d ' %rb 
                        pstring1+='X%d ' %pb
                        pstring1+='X%d ' %sb
                        pstring1+='Y%d' %qb
                        Q1=QubitOperator(pstring1, 0 + 1j)
                        pstring2=''
                        pstring2+='X%d ' %qb 
                        pstring2+='Y%d ' %rb
                        pstring2+='Y%d ' %pb
                        pstring2+='Y%d' %sb
                        Q2=QubitOperator(pstring2, 0 - 1j)
          
                        
                        A=Q1+Q2
                        
                        sqo=str(A)
                        terms=sqo.splitlines()
                        par=0
                        for term in terms:
                            if len(re.findall('Y', term))%2==1:
                                par+=1
                        if par==len(terms):
                            if A not in self.fermi_ops:
                                self.fermi_ops.append(A)
                             
                        pstring1=''
                        pstring1+='X%d ' %ra 
                        pstring1+='X%d ' %pa
                        pstring1+='X%d ' %sb
                        pstring1+='Y%d' %qb
                        Q1=QubitOperator(pstring1, 0 + 1j)
                        pstring2=''
                        pstring2+='X%d ' %qb 
                        pstring2+='Y%d ' %ra
                        pstring2+='Y%d ' %pa
                        pstring2+='Y%d' %sb
                        Q2=QubitOperator(pstring2, 0 - 1j)

                        
                        A=Q1+Q2
                        
                        sqo=str(A)
                        terms=sqo.splitlines()
                        par=0
                        for term in terms:
                            if len(re.findall('Y', term))%2==1:
                                par+=1
                        if par==len(terms):
                            if A not in self.fermi_ops:
                                self.fermi_ops.append(A)
                                
                        pstring1=''
                        pstring1+='X%d ' %rb
                        pstring1+='X%d ' %pb
                        pstring1+='X%d ' %sa
                        pstring1+='Y%d' %qa
                        Q1=QubitOperator(pstring1, 0 + 1j)
                        pstring2=''
                        pstring2+='X%d ' %qa 
                        pstring2+='Y%d ' %rb
                        pstring2+='Y%d ' %pb
                        pstring2+='Y%d' %sa
                        Q2=QubitOperator(pstring2, 0 - 1j)
      
                        
                        A=Q1+Q2
                        
                        sqo=str(A)
                        terms=sqo.splitlines()
                        par=0
                        for term in terms:
                            if len(re.findall('Y', term))%2==1:
                                par+=1
                        if par==len(terms):
                            if A not in self.fermi_ops:
                                self.fermi_ops.append(A)
                        
                        pstring1=''
                        pstring1+='X%d ' %ra
                        pstring1+='X%d ' %pb
                        pstring1+='X%d ' %sb
                        pstring1+='Y%d' %qa
                        Q1=QubitOperator(pstring1, 0 + 1j)
                        pstring2=''
                        pstring2+='X%d ' %qa 
                        pstring2+='Y%d ' %ra
                        pstring2+='Y%d ' %pb
                        pstring2+='Y%d' %sb
                        Q2=QubitOperator(pstring2, 0 - 1j)

                        
                        A=Q1+Q2
                        sqo=str(A)
                        terms=sqo.splitlines()
                        par=0
                        for term in terms:
                            if len(re.findall('Y', term))%2==1:
                                par+=1
                        if par==len(terms):
                            if A not in self.fermi_ops:
                                self.fermi_ops.append(A)
                                
                                
                        pstring1=''
                        pstring1+='X%d ' %rb
                        pstring1+='X%d ' %pa
                        pstring1+='X%d ' %sa
                        pstring1+='Y%d' %qb
                        Q1=QubitOperator(pstring1, 0 + 1j)
                        pstring2=''
                        pstring2+='X%d ' %qb 
                        pstring2+='Y%d ' %rb
                        pstring2+='Y%d ' %pa
                        pstring2+='Y%d' %sa
                        Q2=QubitOperator(pstring2, 0 - 1j)
     
                        
                        A=Q1+Q2
                        
                        sqo=str(A)
                        terms=sqo.splitlines()
                        par=0
                        for term in terms:
                            if len(re.findall('Y', term))%2==1:
                                par+=1
                        if par==len(terms):
                            if A not in self.fermi_ops:
                                self.fermi_ops.append(A)

    

        self.n_ops = len(self.fermi_ops)
        print(" Number of qubit excitation operators: ", self.n_ops)
        return

class GSD_extract_JW(OperatorPool):

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                termA = FermionOperator(((pa, 1), (qa, 0)))
                termA += FermionOperator(((pb, 1), (qb, 0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                # Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA / np.sqrt(coeffA)
                    self.fermi_ops.append(termA)

        pq = -1
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                pq += 1

                rs = -1
                for r in range(0, self.n_orb):
                    ra = 2 * r
                    rb = 2 * r + 1

                    for s in range(r, self.n_orb):
                        sa = 2 * s
                        sb = 2 * s + 1

                        rs += 1

                        if (pq > rs):
                            continue

                        termA = FermionOperator(((ra, 1), (pa, 0), (sa, 1), (qa, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sb, 1), (qb, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), 1 / np.sqrt(12))

                        termB = FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / 2.0)
                        termB += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), -1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), -1 / 2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        # Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA / np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB / np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.jordan_wigner(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            flip = []
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                        flip.append(k)
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                        flip.append(k)
            flip.sort()
            z_string = list(range(flip[0] + 1,flip[1]))
            if len(flip) == 4:
                for i in range(flip[2] + 1, flip[3]):
                    z_string.append(i)
            print("Z string:", z_string)
            for i in z_string:
                b_string[i] += 1
                b_string[i] = b_string[i] % 2
            for k in range(n):
                if b_string[k] == 1:
                    if b_string[k + n] == 0:
                        pauli_string += 'Z%d ' % k
            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)
        print(" Number of pauli operators: ", self.n_ops)

        return #get individual pauli string from singlet GSD up down ....


class GSD_extractZ_JW(OperatorPool):

    def norm(self, matrix):
        tr = (matrix.dot(matrix.transpose().conj())).diagonal().sum().real
        return tr

    def com(self, M1, M2):
        comm = M1.dot(M2)-M2.dot(M1)
        return comm

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                termA = FermionOperator(((pa, 1), (qa, 0)))
                termA += FermionOperator(((pb, 1), (qb, 0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                # Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA / np.sqrt(coeffA)
                    self.fermi_ops.append(termA)

        pq = -1
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                pq += 1

                rs = -1
                for r in range(0, self.n_orb):
                    ra = 2 * r
                    rb = 2 * r + 1

                    for s in range(r, self.n_orb):
                        sa = 2 * s
                        sb = 2 * s + 1

                        rs += 1

                        if (pq > rs):
                            continue

                        termA = FermionOperator(((ra, 1), (pa, 0), (sa, 1), (qa, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sb, 1), (qb, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), 1 / np.sqrt(12))

                        termB = FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / 2.0)
                        termB += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), -1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), -1 / 2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        # Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA / np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB / np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.jordan_wigner(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                    if b_string[k + n] == 0:
                        pauli_string += 'Z%d ' % k

            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)

        print(" Number of pauli operators: ", self.n_ops)

        return #get individual pauli string from singlet GSD up down ....

class GSD_extractexp_JW(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                termA = FermionOperator(((pa, 1), (qa, 0)))
                termA += FermionOperator(((pb, 1), (qb, 0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                # Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA / np.sqrt(coeffA)
                    self.fermi_ops.append(termA)

        pq = -1
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                pq += 1

                rs = -1
                for r in range(0, self.n_orb):
                    ra = 2 * r
                    rb = 2 * r + 1

                    for s in range(r, self.n_orb):
                        sa = 2 * s
                        sb = 2 * s + 1

                        rs += 1

                        if (pq > rs):
                            continue

                        termA = FermionOperator(((ra, 1), (pa, 0), (sa, 1), (qa, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sb, 1), (qb, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), 1 / np.sqrt(12))

                        termB = FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / 2.0)
                        termB += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), -1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), -1 / 2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        # Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA / np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB / np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.jordan_wigner(i)
            for line in pauli.terms:
                line = str(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                    #if b_string[k + n] == 0:
                    #    pauli_string += 'Z%d ' % k

            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)

        print(" Number of pauli operators: ", self.n_ops)

        return #get individual pauli string from singlet GSD up down ....

class SD_extract_JW(OperatorPool):

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form SD operators")

        self.fermi_ops = []

        n_occ = self.n_occ
        n_vir = self.n_vir

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                termA =  FermionOperator(((aa,1),(ia,0)), 1/np.sqrt(2))
                termA += FermionOperator(((ab,1),(ib,0)), 1/np.sqrt(2))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(termA)


        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for j in range(i,n_occ):
                ja = 2*j
                jb = 2*j+1

                for a in range(0,n_vir):
                    aa = 2*n_occ + 2*a
                    ab = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        ba = 2*n_occ + 2*b
                        bb = 2*n_occ + 2*b+1

                        termA =  FermionOperator(((aa,1),(ba,1),(ia,0),(ja,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(bb,1),(ib,0),(jb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), 1/np.sqrt(12))

                        termB  = FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/2)
                        termB += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), -1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), -1/2)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0
                        coeffB = 0
                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t
                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t


                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.jordan_wigner(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            flip = []
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                        flip.append(k)
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                        flip.append(k)
            flip.sort()
            z_string = list(range(flip[0] + 1,flip[1]))
            if len(flip) == 4:
                for i in range(flip[2] + 1, flip[3]):
                    z_string.append(i)
            print("Z string:", z_string)
            for i in z_string:
                b_string[i] += 1
                b_string[i] = b_string[i] % 2
            for k in range(n):
                if b_string[k] == 1:
                    if b_string[k + n] == 0:
                        pauli_string += 'Z%d ' % k
            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)


        print(" Number of pauli operators: ", self.n_ops)

        return

class SD_extractZ_JW(OperatorPool):

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form SD operators")

        self.fermi_ops = []

        n_occ = self.n_occ
        n_vir = self.n_vir

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                termA =  FermionOperator(((aa,1),(ia,0)), 1/np.sqrt(2))
                termA += FermionOperator(((ab,1),(ib,0)), 1/np.sqrt(2))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(termA)


        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for j in range(i,n_occ):
                ja = 2*j
                jb = 2*j+1

                for a in range(0,n_vir):
                    aa = 2*n_occ + 2*a
                    ab = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        ba = 2*n_occ + 2*b
                        bb = 2*n_occ + 2*b+1

                        termA =  FermionOperator(((aa,1),(ba,1),(ia,0),(ja,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(bb,1),(ib,0),(jb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), 1/np.sqrt(12))

                        termB  = FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/2)
                        termB += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), -1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), -1/2)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0
                        coeffB = 0
                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t
                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t


                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.jordan_wigner(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                    if b_string[k + n] == 0:
                        pauli_string += 'Z%d ' % k
            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)


        print(" Number of pauli operators: ", self.n_ops)

        return

class SD_extractexp_JW(OperatorPool):

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form SD operators")

        self.fermi_ops = []

        n_occ = self.n_occ
        n_vir = self.n_vir

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                termA =  FermionOperator(((aa,1),(ia,0)), 1/np.sqrt(2))
                termA += FermionOperator(((ab,1),(ib,0)), 1/np.sqrt(2))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(termA)


        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for j in range(i,n_occ):
                ja = 2*j
                jb = 2*j+1

                for a in range(0,n_vir):
                    aa = 2*n_occ + 2*a
                    ab = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        ba = 2*n_occ + 2*b
                        bb = 2*n_occ + 2*b+1

                        termA =  FermionOperator(((aa,1),(ba,1),(ia,0),(ja,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(bb,1),(ib,0),(jb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), 1/np.sqrt(12))

                        termB  = FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/2)
                        termB += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), -1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), -1/2)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0
                        coeffB = 0
                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t
                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t


                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.jordan_wigner(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)


        print(" Number of pauli operators: ", self.n_ops)

        return

class singlet_SD_BK(OperatorPool):
    def generate_SQ_Operators(self):
        """
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet SD operators")
        self.fermi_ops = []

        n_occ = self.n_occ
        n_vir = self.n_vir

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                termA =  FermionOperator(((aa,1),(ia,0)), 1/np.sqrt(2))
                termA += FermionOperator(((ab,1),(ib,0)), 1/np.sqrt(2))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(openfermion.bravyi_kitaev(termA))


        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for j in range(i,n_occ):
                ja = 2*j
                jb = 2*j+1

                for a in range(0,n_vir):
                    aa = 2*n_occ + 2*a
                    ab = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        ba = 2*n_occ + 2*b
                        bb = 2*n_occ + 2*b+1

                        termA =  FermionOperator(((aa,1),(ba,1),(ia,0),(ja,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(bb,1),(ib,0),(jb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), 1/np.sqrt(12))

                        termB  = FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/2)
                        termB += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), -1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), -1/2)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0
                        coeffB = 0
                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t
                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t


                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(openfermion.bravyi_kitaev(termA))

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(openfermion.bravyi_kitaev(termB))

        self.n_ops = len(self.fermi_ops)
        print(" Number of operators: ", self.n_ops)
        return

class singlet_GSD_BK(OperatorPool):
    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                termA =  FermionOperator(((pa,1),(qa,0)))
                termA += FermionOperator(((pb,1),(qb,0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(openfermion.bravyi_kitaev(termA))


        pq = -1
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                pq += 1

                rs = -1
                for r in range(0,self.n_orb):
                    ra = 2*r
                    rb = 2*r+1

                    for s in range(r,self.n_orb):
                        sa = 2*s
                        sb = 2*s+1

                        rs += 1

                        if(pq > rs):
                            continue

                        termA =  FermionOperator(((ra,1),(pa,0),(sa,1),(qa,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pb,0),(sb,1),(qb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ra,1),(pa,0),(sb,1),(qb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pb,0),(sa,1),(qa,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ra,1),(pb,0),(sb,1),(qa,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pa,0),(sa,1),(qb,0)), 1/np.sqrt(12))

                        termB =  FermionOperator(((ra,1),(pa,0),(sb,1),(qb,0)),  1/2.0)
                        termB += FermionOperator(((rb,1),(pb,0),(sa,1),(qa,0)),  1/2.0)
                        termB += FermionOperator(((ra,1),(pb,0),(sb,1),(qa,0)), -1/2.0)
                        termB += FermionOperator(((rb,1),(pa,0),(sa,1),(qb,0)), -1/2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append((openfermion.bravyi_kitaev(termA)))

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append((openfermion.bravyi_kitaev(termB)))

        self.n_ops = len(self.fermi_ops)
        print(" Number of operators: ", self.n_ops)
        return


class GSD_extractZ_BK(OperatorPool):

    def norm(self, matrix):
        tr = (matrix.dot(matrix.transpose().conj())).diagonal().sum().real
        return tr

    def com(self, M1, M2):
        comm = M1.dot(M2)-M2.dot(M1)
        return comm

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                termA = FermionOperator(((pa, 1), (qa, 0)))
                termA += FermionOperator(((pb, 1), (qb, 0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                # Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA / np.sqrt(coeffA)
                    self.fermi_ops.append(termA)

        pq = -1
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                pq += 1

                rs = -1
                for r in range(0, self.n_orb):
                    ra = 2 * r
                    rb = 2 * r + 1

                    for s in range(r, self.n_orb):
                        sa = 2 * s
                        sb = 2 * s + 1

                        rs += 1

                        if (pq > rs):
                            continue

                        termA = FermionOperator(((ra, 1), (pa, 0), (sa, 1), (qa, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sb, 1), (qb, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), 1 / np.sqrt(12))

                        termB = FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / 2.0)
                        termB += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), -1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), -1 / 2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        # Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA / np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB / np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.bravyi_kitaev(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                    if b_string[k + n] == 0:
                        pauli_string += 'Z%d ' % k
            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)

        print(" Number of pauli operators: ", self.n_ops)

        return #get individual pauli string from singlet GSD up down ....


        for op in self.fermi_ops:
            print(op)

        self.n_ops = len(self.fermi_ops)
        print(" Number of operators: ", self.n_ops)
        return


class SD_extractexp_BK(OperatorPool):

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form SD operators")

        self.fermi_ops = []

        n_occ = self.n_occ
        n_vir = self.n_vir

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                termA =  FermionOperator(((aa,1),(ia,0)), 1/np.sqrt(2))
                termA += FermionOperator(((ab,1),(ib,0)), 1/np.sqrt(2))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(termA)


        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for j in range(i,n_occ):
                ja = 2*j
                jb = 2*j+1

                for a in range(0,n_vir):
                    aa = 2*n_occ + 2*a
                    ab = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        ba = 2*n_occ + 2*b
                        bb = 2*n_occ + 2*b+1

                        termA =  FermionOperator(((aa,1),(ba,1),(ia,0),(ja,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(bb,1),(ib,0),(jb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), 1/np.sqrt(12))

                        termB  = FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/2)
                        termB += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), -1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), -1/2)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0
                        coeffB = 0
                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t
                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t


                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.bravyi_kitaev(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)


        print(" Number of pauli operators: ", self.n_ops)

        return

class SD_extractZ_BK(OperatorPool):

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form SD operators")

        self.fermi_ops = []

        n_occ = self.n_occ
        n_vir = self.n_vir

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                termA =  FermionOperator(((aa,1),(ia,0)), 1/np.sqrt(2))
                termA += FermionOperator(((ab,1),(ib,0)), 1/np.sqrt(2))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(termA)


        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for j in range(i,n_occ):
                ja = 2*j
                jb = 2*j+1

                for a in range(0,n_vir):
                    aa = 2*n_occ + 2*a
                    ab = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        ba = 2*n_occ + 2*b
                        bb = 2*n_occ + 2*b+1

                        termA =  FermionOperator(((aa,1),(ba,1),(ia,0),(ja,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(bb,1),(ib,0),(jb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), 1/np.sqrt(12))

                        termB  = FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/2)
                        termB += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), -1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), -1/2)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0
                        coeffB = 0
                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t
                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t


                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.bravyi_kitaev(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                    if b_string[k + n] == 0:
                        pauli_string += 'Z%d ' % k
            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)


        print(" Number of pauli operators: ", self.n_ops)

        return
        print(" Number of pauli operators: ", self.n_ops)

        return

class GSD_extractexp_BK(OperatorPool):



    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                termA = FermionOperator(((pa, 1), (qa, 0)))
                termA += FermionOperator(((pb, 1), (qb, 0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                # Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA / np.sqrt(coeffA)
                    self.fermi_ops.append(termA)

        pq = -1
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                pq += 1

                rs = -1
                for r in range(0, self.n_orb):
                    ra = 2 * r
                    rb = 2 * r + 1

                    for s in range(r, self.n_orb):
                        sa = 2 * s
                        sb = 2 * s + 1

                        rs += 1

                        if (pq > rs):
                            continue

                        termA = FermionOperator(((ra, 1), (pa, 0), (sa, 1), (qa, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sb, 1), (qb, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), 1 / np.sqrt(12))

                        termB = FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / 2.0)
                        termB += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), -1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), -1 / 2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        # Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA / np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB / np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = openfermion.transforms.bravyi_kitaev(i)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)
        print(" Number of pauli operators: ", self.n_ops)

        return #get individual pauli string from singlet GSD up down ....

class GSD_extract_BK(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """



        nqub=self.n_spin_orb


        def beta():
            bi=np.ones((1,1), dtype=int)
            for i in range(math.ceil(math.log(nqub,2))):
                bi=np.kron(np.identity(2), bi)
                bi[0,:]=1
            bi=bi[-nqub::,-nqub::]

            return bi

        bmat=beta()
        invbeta=np.linalg.inv(bmat)%2
        lista=[]
        self.fermi_ops=[]

        def U(i):
            u=[]
            for up in range(nqub-i-1):
                if bmat[up,nqub-i-1]==1:
                    u.append(nqub-up-1)
            return u

        def F(i):
            f=[]
            for r in range(nqub-i, nqub):
                if invbeta[nqub-1-i,r]==1:
                    f.append(nqub-1-r)
            return f

        def lad(i):
            first=np.zeros((3,nqub))
            second=np.zeros((3,nqub))
            first[0,U(i)]=1
            first[0,i]=1
            second[0,U(i)]=1
            second[1,i]=1
            return first, second

        def singex(a, b):
            ladi=lad(a)
            ladj=lad(b)
            ab=ladi[0]+ladj[1]
            ab=ab%2
            ba=ladi[1]+ladj[0]
            ba=ba%2
            for matr in [ab,ba]:
                opa=''
                for k in range(3):
                    for l in range(nqub):
                        if k==0 and matr[k,l]==1:
                            opa += 'X%d ' % l
                        if k==1 and matr[k,l]==1:
                            opa += 'Y%d ' % l
                        if k==2 and matr[k,l]==1:
                            opa += 'Z%d ' % l
                A = QubitOperator(opa, 0 + 1j)
                sqo=str(A)
                if len(re.findall('Y', sqo))%2==1:
                    if len(re.findall('0j', sqo))%2==1:
                        A=1j*A
                    if opa not in lista:
                        lista.append(opa)


                        print("Pauli:", opa)
                        self.fermi_ops.append(A)
            return


        def doubex(a, b, c, d):
            ladi=lad(a)
            ladj=lad(b)
            ladk=lad(c)
            ladl=lad(d)
            aaab=ladi[0]+ladj[0]+ladk[0]+ladl[1]
            aaab=aaab%2
            aabb=ladi[0]+ladj[0]+ladk[1]+ladl[1]
            aabb=aabb%2
            aaba=ladi[0]+ladj[0]+ladk[1]+ladl[0]
            aaba=aaba%2
            abaa=ladi[0]+ladj[1]+ladk[0]+ladl[0]
            abaa=abaa%2
            abab=ladi[0]+ladj[1]+ladk[0]+ladl[1]
            abab=abab%2
            abba=ladi[0]+ladj[1]+ladk[1]+ladl[0]
            abba=abba%2
            abbb=ladi[0]+ladj[1]+ladk[1]+ladl[1]
            abbb=abbb%2
            baab=ladi[1]+ladj[0]+ladk[0]+ladl[1]
            baab=baab%2
            babb=ladi[1]+ladj[0]+ladk[1]+ladl[1]
            babb=babb%2
            baba=ladi[1]+ladj[0]+ladk[1]+ladl[0]
            baba=baba%2
            bbaa=ladi[1]+ladj[1]+ladk[0]+ladl[0]
            bbaa=bbaa%2
            bbab=ladi[1]+ladj[1]+ladk[0]+ladl[1]
            bbab=bbab%2
            bbba=ladi[1]+ladj[1]+ladk[1]+ladl[0]
            bbba=bbba%2
            bbbb=ladi[1]+ladj[1]+ladk[1]+ladl[1]
            bbbb=bbbb%2
            baaa=ladi[1]+ladj[0]+ladk[0]+ladl[0]
            baaa=baaa%2
            baab=ladi[1]+ladj[0]+ladk[0]+ladl[1]
            baab=baab%2
            for matr in [aaab, aabb, aaba, abaa, abab, abbb, abba, baab, babb, baba, bbaa, bbab, bbbb, bbba, baaa, baab]:
                opa=''
                for k in range(3):
                    for l in range(nqub):
                        if k==0 and matr[k,l]==1:
                            opa += 'X%d ' % l
                        if k==1 and matr[k,l]==1:
                            opa += 'Y%d ' % l
                        if k==2 and matr[k,l]==1:
                            opa += 'Z%d ' % l

                A = QubitOperator(opa, 0 + 1j)
                sqo=str(A)
                if len(re.findall('Y', sqo))%2==1:
                    if len(re.findall('0j', sqo))%2==1:
                        A=1j*A
                    if opa not in lista:
                        lista.append(opa)



                        self.fermi_ops.append(A)



            return

        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                singex(pa, qa)
                singex(pb, qb)


        pq = -1
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                pq += 1

                rs = -1
                for r in range(0, self.n_orb):
                    ra = 2 * r
                    rb = 2 * r + 1

                    for s in range(r, self.n_orb):
                        sa = 2 * s
                        sb = 2 * s + 1

                        rs += 1

                        if (pq > rs):
                            continue

                        doubex(ra, pa, sa, qa)
                        doubex(rb, pb, sb, qb)
                        doubex(ra, pa, sb, qb)
                        doubex(rb, pb, sa, qa)
                        doubex(ra, pb, sb, qa)
                        doubex(rb, pa, sa, qb)





        self.n_ops = len(self.fermi_ops)
        return


class SD_extract_BK(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """



        nqub=self.n_spin_orb
        n_occ = self.n_occ
        n_vir = self.n_vir

        def beta():
            bi=np.ones((1,1), dtype=int)
            for i in range(math.ceil(math.log(nqub,2))):
                bi=np.kron(np.identity(2), bi)
                bi[0,:]=1
            bi=bi[-nqub::,-nqub::]

            return bi

        bmat=beta()
        invbeta=np.linalg.inv(bmat)%2
        lista=[]
        self.fermi_ops=[]

        def U(i):
            u=[]
            for up in range(nqub-i-1):
                if bmat[up,nqub-i-1]==1:
                    u.append(nqub-up-1)
            return u

        def F(i):
            f=[]
            for r in range(nqub-i, nqub):
                if invbeta[nqub-1-i,r]==1:
                    f.append(nqub-1-r)
            return f

        def lad(i):
            first=np.zeros((3,nqub))
            second=np.zeros((3,nqub))
            first[0,U(i)]=1
            first[0,i]=1
            second[0,U(i)]=1
            second[1,i]=1
            return first, second

        def singex(a, b):
            ladi=lad(a)
            ladj=lad(b)
            ab=ladi[0]+ladj[1]
            ab=ab%2
            ba=ladi[1]+ladj[0]
            ba=ba%2
            for matr in [ab,ba]:
                opa=''
                for k in range(3):
                    for l in range(nqub):
                        if k==0 and matr[k,l]==1:
                            opa += 'X%d ' % l
                        if k==1 and matr[k,l]==1:
                            opa += 'Y%d ' % l
                        if k==2 and matr[k,l]==1:
                            opa += 'Z%d ' % l
                A = QubitOperator(opa, 0 + 1j)
                sqo=str(A)
                if len(re.findall('Y', sqo))%2==1:
                    if len(re.findall('0j', sqo))%2==1:
                        A=1j*A
                    if opa not in lista:
                        lista.append(opa)


                        print("Pauli:", opa)
                        self.fermi_ops.append(A)
            return


        def doubex(a, b, c, d):
            ladi=lad(a)
            ladj=lad(b)
            ladk=lad(c)
            ladl=lad(d)
            aaab=ladi[0]+ladj[0]+ladk[0]+ladl[1]
            aaab=aaab%2
            aabb=ladi[0]+ladj[0]+ladk[1]+ladl[1]
            aabb=aabb%2
            aaba=ladi[0]+ladj[0]+ladk[1]+ladl[0]
            aaba=aaba%2
            abaa=ladi[0]+ladj[1]+ladk[0]+ladl[0]
            abaa=abaa%2
            abab=ladi[0]+ladj[1]+ladk[0]+ladl[1]
            abab=abab%2
            abba=ladi[0]+ladj[1]+ladk[1]+ladl[0]
            abba=abba%2
            abbb=ladi[0]+ladj[1]+ladk[1]+ladl[1]
            abbb=abbb%2
            baab=ladi[1]+ladj[0]+ladk[0]+ladl[1]
            baab=baab%2
            babb=ladi[1]+ladj[0]+ladk[1]+ladl[1]
            babb=babb%2
            baba=ladi[1]+ladj[0]+ladk[1]+ladl[0]
            baba=baba%2
            bbaa=ladi[1]+ladj[1]+ladk[0]+ladl[0]
            bbaa=bbaa%2
            bbab=ladi[1]+ladj[1]+ladk[0]+ladl[1]
            bbab=bbab%2
            bbba=ladi[1]+ladj[1]+ladk[1]+ladl[0]
            bbba=bbba%2
            bbbb=ladi[1]+ladj[1]+ladk[1]+ladl[1]
            bbbb=bbbb%2
            baaa=ladi[1]+ladj[0]+ladk[0]+ladl[0]
            baaa=baaa%2
            baab=ladi[1]+ladj[0]+ladk[0]+ladl[1]
            baab=baab%2
            for matr in [aaab, aabb, aaba, abaa, abab, abbb, abba, baab, babb, baba, bbaa, bbab, bbbb, bbba, baaa, baab]:
                opa=''
                for k in range(3):
                    for l in range(nqub):
                        if k==0 and matr[k,l]==1:
                            opa += 'X%d ' % l
                        if k==1 and matr[k,l]==1:
                            opa += 'Y%d ' % l
                        if k==2 and matr[k,l]==1:
                            opa += 'Z%d ' % l

                A = QubitOperator(opa, 0 + 1j)
                sqo=str(A)
                if len(re.findall('Y', sqo))%2==1:
                    if len(re.findall('0j', sqo))%2==1:
                        A=1j*A
                    if opa not in lista:
                        lista.append(opa)



                        self.fermi_ops.append(A)



            return

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                singex(ia, aa)
                singex(ib, ab)


        for i in range(0,n_occ):
            pa = 2*i
            pb = 2*i+1

            for j in range(i,n_occ):
                qa = 2*j
                qb = 2*j+1

                for a in range(0,n_vir):
                    ra = 2*n_occ + 2*a
                    rb = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        sa = 2*n_occ + 2*b
                        sb = 2*n_occ + 2*b+1




                        doubex(ra, pa, sa, qa)
                        doubex(rb, pb, sb, qb)
                        doubex(ra, pa, sb, qb)
                        doubex(rb, pb, sa, qa)
                        doubex(ra, pb, sb, qa)
                        doubex(rb, pa, sa, qb)





        self.n_ops = len(self.fermi_ops)
        return




class qubit_excitation_BK(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """



        nqub=self.n_spin_orb

        def beta():
            bi=np.ones((1,1), dtype=int)
            for i in range(math.ceil(math.log(nqub,2))):
                bi=np.kron(np.identity(2), bi)
                bi[0,:]=1
            bi=bi[-nqub::,-nqub::]

            return bi

        bmat=beta()
        invbeta=np.linalg.inv(bmat)%2
        lista=[]
        self.fermi_ops=[]

        def U(i):
            u=[]
            for up in range(nqub-i-1):
                if bmat[up,nqub-i-1]==1:
                    u.append(nqub-up-1)
            return u

        def F(i):
            if i%2==0:
                f=[]
                return f
            f=[]
            for r in range(nqub-i, nqub):
                if invbeta[nqub-1-i,r]==1:
                    f.append(nqub-1-r)
            return f


        def singex(a,b):
            ua=U(a)
            ub=U(b)
            fa=F(a)
            fb=F(b)
            tone=''
            ttwo=''

            for x in ua:
                tone+='X%d ' % x
            tone+='X%d ' % a
            for x in ub:
                tone+='X%d ' % x
            tone+='Y%d ' % b
            for f in fb:
                tone+='Z%d ' % f



            for x in ua:
                ttwo+='X%d ' % x
            ttwo+='Y%d ' % a
            for f in fa:
                ttwo+='Z%d ' % f
            for x in ub:
                ttwo+='X%d ' % x
            ttwo+='X%d ' % b



            qo=QubitOperator(tone, 1j) + QubitOperator(ttwo, -1j)
            sqo=str(qo)
            terms=sqo.splitlines()
            par=0
            for term in terms:
                if len(re.findall('Y', term))%2==1:
                    par+=1
                    if par==len(terms):
                        if qo not in self.fermi_ops:
                            self.fermi_ops.append(qo)
            return


        def doubex(a,b,c,d):
            ua=U(a)
            ub=U(b)
            uc=U(c)
            ud=U(d)
            fa=F(a)
            fb=F(b)
            fc=F(c)
            fd=F(d)


            def dob(i,j,k,l):
                sop=''

                for x in ua:
                    sop+='X%d ' % x
                if i == 'X':
                    sop+='X%d ' % a
                elif i == 'Y':
                    sop+='Y%d ' %a
                    for f in fa:
                        sop+='Z%d ' %f


                for x in ub:
                    sop+='X%d ' % x
                if j == 'X':
                    sop+='X%d ' % b
                elif j == 'Y':
                    sop+='Y%d ' %b
                    for f in fb:
                        sop+='Z%d ' %f


                for x in uc:
                    sop+='X%d ' % x
                if k == 'X':
                    sop+='X%d ' % c
                elif k == 'Y':
                    sop+='Y%d ' %c
                    for f in fc:
                        sop+='Z%d ' %f


                for x in ud:
                    sop+='X%d ' % x
                if l == 'X':
                    sop+='X%d ' % d
                elif l == 'Y':
                    sop+='Y%d ' %d
                    for f in fd:
                        sop+='Z%d ' %f

                return sop



            qo=QubitOperator(dob('X','Y','X','X'), 0+1j) + QubitOperator(dob('Y','X','X','X'), 0+1j)+ QubitOperator(dob('Y','Y','Y','X'), 0+1j)+ QubitOperator(dob('Y','Y','X','Y'), 0+1j)+QubitOperator(dob('X','X','Y','X'), 0-1j)+QubitOperator(dob('X','X','X','Y'), 0-1j)+QubitOperator(dob('Y','X','Y','Y'), 0-1j)+QubitOperator(dob('X','Y','Y','Y'), 0-1j)
            sqo=str(qo)
            terms=sqo.splitlines()
            par=0
            for term in terms:
                if len(re.findall('Y', term))%2==1:
                    par+=1
                    if par==len(terms):
                        if qo not in self.fermi_ops:
                            self.fermi_ops.append(qo)
            return




        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                singex(pa,qa)
                singex(pb,qb)


        pq = -1
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                pq += 1

                rs = -1
                for r in range(0,self.n_orb):
                    ra = 2*r
                    rb = 2*r+1

                    for s in range(r,self.n_orb):
                        sa = 2*s
                        sb = 2*s+1

                        rs += 1

                        if(pq > rs):
                            continue

                        doubex(ra,pa,sa,qa)
                        doubex(rb,pb,sb,qb)
                        doubex(ra,pa,sb,qb)
                        doubex(rb,pb,sa,qa)
                        doubex(ra,pb,sb,qa)
                        doubex(rb,pa,sa,qb)








        self.n_ops = len(self.fermi_ops)
        return


class mcp_H4(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """


        self.fermi_ops=[]
        lista=[
        'YIXIYIYI',
        'ZYXIYIZY',
        'YIZYXIZY',
        'ZZYXYYII',
        'XXIZIIXY',
        'YIZYZXYI',
        'XIYZYZYI',
        'XZIIYZII',
        'ZXXZZXYI',
        'XXIIIIXY',
        'IYYZXIZY']

        for i in lista:

            op=''
            ind=0
            for p in i:
                if p != 'I' :

                    op+=p
                    op+=str(ind)+' '

                ind+=1





            qo=QubitOperator(op, 1j)
            self.fermi_ops.append(qo)

        self.n_ops = len(self.fermi_ops)
        return



class mcp_H4_noZ(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """


        self.fermi_ops=[]
        lista=[
        'YIXIYIYI',
        'ZYXIYIZY',
        'YIZYXIZY',
        'ZZYXYYII',
        'XXIZIIXY',
        'YIZYZXYI',
        'XIYZYZYI',
        'XZIIYZII',
        'ZXXZZXYI',
        'XXIIIIXY',
        'IYYZXIZY']

        for i in lista:

            op=''
            ind=0
            for p in i:
                if p != 'I' :
                    if p != 'Z' :


                        op+=p
                        op+=str(ind)+' '

                ind+=1





            qo=QubitOperator(op, 1j)
            self.fermi_ops.append(qo)

        self.n_ops = len(self.fermi_ops)
        return

class singlet_SD_PT(OperatorPool):
    def generate_SQ_Operators(self):
        """
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet SD operators")
        self.fermi_ops = []

        n_occ = self.n_occ
        n_vir = self.n_vir

        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for a in range(0,n_vir):
                aa = 2*n_occ + 2*a
                ab = 2*n_occ + 2*a+1

                termA =  FermionOperator(((aa,1),(ia,0)), 1/np.sqrt(2))
                termA += FermionOperator(((ab,1),(ib,0)), 1/np.sqrt(2))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(parity(termA, self.n_spin_orb))


        for i in range(0,n_occ):
            ia = 2*i
            ib = 2*i+1

            for j in range(i,n_occ):
                ja = 2*j
                jb = 2*j+1

                for a in range(0,n_vir):
                    aa = 2*n_occ + 2*a
                    ab = 2*n_occ + 2*a+1

                    for b in range(a,n_vir):
                        ba = 2*n_occ + 2*b
                        bb = 2*n_occ + 2*b+1

                        termA =  FermionOperator(((aa,1),(ba,1),(ia,0),(ja,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(bb,1),(ib,0),(jb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), 1/np.sqrt(12))

                        termB  = FermionOperator(((aa,1),(bb,1),(ia,0),(jb,0)), 1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ib,0),(ja,0)), 1/2)
                        termB += FermionOperator(((aa,1),(bb,1),(ib,0),(ja,0)), -1/2)
                        termB += FermionOperator(((ab,1),(ba,1),(ia,0),(jb,0)), -1/2)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0
                        coeffB = 0
                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t
                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t


                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(parity(termA, self.n_spin_orb))

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(parity(termB, self.n_spin_orb))

        self.n_ops = len(self.fermi_ops)
        print(" Number of operators: ", self.n_ops)
        return

class singlet_GSD_PT(OperatorPool):
    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                termA =  FermionOperator(((pa,1),(qa,0)))
                termA += FermionOperator(((pb,1),(qb,0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                #Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA/np.sqrt(coeffA)
                    self.fermi_ops.append(parity(termA, self.n_spin_orb))


        pq = -1
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                pq += 1

                rs = -1
                for r in range(0,self.n_orb):
                    ra = 2*r
                    rb = 2*r+1

                    for s in range(r,self.n_orb):
                        sa = 2*s
                        sb = 2*s+1

                        rs += 1

                        if(pq > rs):
                            continue

                        termA =  FermionOperator(((ra,1),(pa,0),(sa,1),(qa,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pb,0),(sb,1),(qb,0)), 2/np.sqrt(12))
                        termA += FermionOperator(((ra,1),(pa,0),(sb,1),(qb,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pb,0),(sa,1),(qa,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((ra,1),(pb,0),(sb,1),(qa,0)), 1/np.sqrt(12))
                        termA += FermionOperator(((rb,1),(pa,0),(sa,1),(qb,0)), 1/np.sqrt(12))

                        termB =  FermionOperator(((ra,1),(pa,0),(sb,1),(qb,0)),  1/2.0)
                        termB += FermionOperator(((rb,1),(pb,0),(sa,1),(qa,0)),  1/2.0)
                        termB += FermionOperator(((ra,1),(pb,0),(sb,1),(qa,0)), -1/2.0)
                        termB += FermionOperator(((rb,1),(pa,0),(sa,1),(qb,0)), -1/2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        #Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA/np.sqrt(coeffA)
                            self.fermi_ops.append(parity(termA, self.n_spin_orb))

                        if termB.many_body_order() > 0:
                            termB = termB/np.sqrt(coeffB)
                            self.fermi_ops.append(parity(termB, self.n_spin_orb))

        self.n_ops = len(self.fermi_ops)
        print(" Number of operators: ", self.n_ops)
        return


class qubit_excitation_PT(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """
        self.fermi_ops=[]


        nqub=self.n_spin_orb


        def sqe(i,j):
            qo1=QubitOperator()
            qo2=QubitOperator()
            qos=''
            qos+='Y%a ' % i
            qos+='X%a ' % j
            if j>0:
                qos+='Z%a ' % (j-1)
            if len(re.findall('Y', qos))%2==1:
                qo1=QubitOperator(qos, 1j)
            qos=''
            qos+='X%a ' % i
            if i>0:
                qos+='Z%a ' % (i-1)
            qos+='Y%a ' % j
            if len(re.findall('Y', qos))%2==1:
                qo2=QubitOperator(qos, -1j)
            qo=qo1+qo2
            sqo=str(qo)
            terms=sqo.splitlines()
            par=0
            for term in terms:
                if len(re.findall('Y', term))%2==1:
                    par+=1
                    if par==len(terms):
                        if qo not in self.fermi_ops:
                            self.fermi_ops.append(qo)
            return


        def dqe(i,j,k,l):
            qo8=QubitOperator()
            qo7=QubitOperator()
            qo6=QubitOperator()
            qo5=QubitOperator()
            qo4=QubitOperator()
            qo3=QubitOperator()
            qo2=QubitOperator()
            qo1=QubitOperator()
            qos=''
            qos+='Y%a ' % i
            qos+='X%a ' % j
            if j>0:
                qos+='Z%a ' % (j-1)
            qos+='X%a ' % k
            if k>0:
                qos+='Z%a ' % (k-1)
            qos+='X%a ' % l
            if l>0:
                qos+='Z%a ' % (l-1)
            if len(re.findall('Y', qos))%2==1:
                qo1=QubitOperator(qos, 1j)
            qos=''
            qos+='X%a ' % i
            if i>0:
                qos+='Z%a ' % (i-1)
            qos+='Y%a ' % j
            qos+='X%a ' % k
            if k>0:
                qos+='Z%a ' % (k-1)
            qos+='X%a ' % l
            if l>0:
                qos+='Z%a ' % (l-1)
            if len(re.findall('Y', qos))%2==1:
                qo2=QubitOperator(qos, 1j)
            qos=''
            qos+='X%a ' % i
            if i>0:
                qos+='Z%a ' % (i-1)
            qos+='X%a ' % j
            if j>0:
                qos+='Z%a ' % (j-1)
            qos+='Y%a ' % k
            qos+='X%a ' % l
            if l>0:
                qos+='Z%a ' % (l-1)
            if len(re.findall('Y', qos))%2==1:
                qo3=QubitOperator(qos, -1j)
            qos=''
            qos+='X%a ' % i
            if i>0:
                qos+='Z%a ' % (i-1)
            qos+='X%a ' % j
            if j>0:
                qos+='Z%a ' % (j-1)
            qos+='X%a ' % k
            if k>0:
                qos+='Z%a ' % (k-1)
            qos+='Y%a ' % l
            if len(re.findall('Y', qos))%2==1:
                qo4=QubitOperator(qos, -1j)
            qos=''
            qos+='X%a ' % i
            if i>0:
                qos+='Z%a ' % (i-1)
            qos+='Y%a ' % j
            qos+='Y%a ' % k
            qos+='Y%a ' % l
            if len(re.findall('Y', qos))%2==1:
                qo5=QubitOperator(qos, -1j)
            qos=''
            qos+='Y%a ' % i
            qos+='X%a ' % j
            if j>0:
                qos+='Z%a ' % (j-1)
            qos+='Y%a ' % k
            qos+='Y%a ' % l
            if len(re.findall('Y', qos))%2==1:
                qo6=QubitOperator(qos, -1j)
            qos=''
            qos+='Y%a ' % i
            qos+='Y%a ' % j
            qos+='X%a ' % k
            if k>0:
                qos+='Z%a ' % (k-1)
            qos+='Y%a ' % l
            if len(re.findall('Y', qos))%2==1:
                qo7=QubitOperator(qos, 1j)
            qos=''
            qos+='Y%a ' % i
            qos+='Y%a ' % j
            qos+='Y%a ' % k
            qos+='X%a ' % l
            if l>0:
                qos+='Z%a ' % (l-1)
            if len(re.findall('Y', qos))%2==1:
                qo8=QubitOperator(qos, 1j)
            qo=qo1+qo2+qo3+qo4+qo5+qo6+qo7+qo8
            sqo=str(qo)
            terms=sqo.splitlines()
            par=0
            for term in terms:
                if len(re.findall('Y', term))%2==1:
                    par+=1
                    if par==len(terms):
                        if qo not in self.fermi_ops:
                            self.fermi_ops.append(qo)
            return

        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                sqe(pa,qa)
                sqe(pb,qb)


        pq = -1
        for p in range(0,self.n_orb):
            pa = 2*p
            pb = 2*p+1

            for q in range(p,self.n_orb):
                qa = 2*q
                qb = 2*q+1

                pq += 1

                rs = -1
                for r in range(0,self.n_orb):
                    ra = 2*r
                    rb = 2*r+1

                    for s in range(r,self.n_orb):
                        sa = 2*s
                        sb = 2*s+1

                        rs += 1

                        if(pq > rs):
                            continue

                        dqe(ra,pa,sa,qa)
                        dqe(rb,pb,sb,qb)
                        dqe(ra,pa,sb,qb)
                        dqe(rb,pb,sa,qa)
                        dqe(ra,pb,sb,qa)
                        dqe(rb,pa,sa,qb)



        self.n_ops = len(self.fermi_ops)
        print(str(self.n_ops)+' operators in pool')
        return



class GSD_extractZ_PT(OperatorPool):

    def norm(self, matrix):
        tr = (matrix.dot(matrix.transpose().conj())).diagonal().sum().real
        return tr

    def com(self, M1, M2):
        comm = M1.dot(M2)-M2.dot(M1)
        return comm

    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                termA = FermionOperator(((pa, 1), (qa, 0)))
                termA += FermionOperator(((pb, 1), (qb, 0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                # Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA / np.sqrt(coeffA)
                    self.fermi_ops.append(termA)

        pq = -1
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                pq += 1

                rs = -1
                for r in range(0, self.n_orb):
                    ra = 2 * r
                    rb = 2 * r + 1

                    for s in range(r, self.n_orb):
                        sa = 2 * s
                        sb = 2 * s + 1

                        rs += 1

                        if (pq > rs):
                            continue

                        termA = FermionOperator(((ra, 1), (pa, 0), (sa, 1), (qa, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sb, 1), (qb, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), 1 / np.sqrt(12))

                        termB = FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / 2.0)
                        termB += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), -1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), -1 / 2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        # Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA / np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB / np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = parity(i, self.n_spin_orb)
            for line in pauli.terms:
                line = str(line)
                # print(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                    if b_string[k + n] == 0:
                        pauli_string += 'Z%d ' % k

            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)

        print(" Number of pauli operators: ", self.n_ops)

        return #get individual pauli string from singlet GSD up down ....

class GSD_extractexp_PT(OperatorPool):


    def generate_SQ_Operators(self):
        """
        n_orb is number of spatial orbitals assuming that spin orbitals are labelled
        0a,0b,1a,1b,2a,2b,3a,3b,....  -> 0,1,2,3,...
        """

        print(" Form singlet GSD operators")

        self.fermi_ops = []
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                termA = FermionOperator(((pa, 1), (qa, 0)))
                termA += FermionOperator(((pb, 1), (qb, 0)))

                termA -= hermitian_conjugated(termA)

                termA = normal_ordered(termA)

                # Normalize
                coeffA = 0
                for t in termA.terms:
                    coeff_t = termA.terms[t]
                    coeffA += coeff_t * coeff_t

                if termA.many_body_order() > 0:
                    termA = termA / np.sqrt(coeffA)
                    self.fermi_ops.append(termA)

        pq = -1
        for p in range(0, self.n_orb):
            pa = 2 * p
            pb = 2 * p + 1

            for q in range(p, self.n_orb):
                qa = 2 * q
                qb = 2 * q + 1

                pq += 1

                rs = -1
                for r in range(0, self.n_orb):
                    ra = 2 * r
                    rb = 2 * r + 1

                    for s in range(r, self.n_orb):
                        sa = 2 * s
                        sb = 2 * s + 1

                        rs += 1

                        if (pq > rs):
                            continue

                        termA = FermionOperator(((ra, 1), (pa, 0), (sa, 1), (qa, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sb, 1), (qb, 0)), 2 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), 1 / np.sqrt(12))
                        termA += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), 1 / np.sqrt(12))

                        termB = FermionOperator(((ra, 1), (pa, 0), (sb, 1), (qb, 0)), 1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pb, 0), (sa, 1), (qa, 0)), 1 / 2.0)
                        termB += FermionOperator(((ra, 1), (pb, 0), (sb, 1), (qa, 0)), -1 / 2.0)
                        termB += FermionOperator(((rb, 1), (pa, 0), (sa, 1), (qb, 0)), -1 / 2.0)

                        termA -= hermitian_conjugated(termA)
                        termB -= hermitian_conjugated(termB)

                        termA = normal_ordered(termA)
                        termB = normal_ordered(termB)

                        # Normalize
                        coeffA = 0

                        for t in termA.terms:
                            coeff_t = termA.terms[t]
                            coeffA += coeff_t * coeff_t

                        coeffB = 0

                        for t in termB.terms:
                            coeff_t = termB.terms[t]
                            coeffB += coeff_t * coeff_t

                        if termA.many_body_order() > 0:
                            termA = termA / np.sqrt(coeffA)
                            self.fermi_ops.append(termA)

                        if termB.many_body_order() > 0:
                            termB = termB / np.sqrt(coeffB)
                            self.fermi_ops.append(termB)

        self.n_ops = len(self.fermi_ops)
        print(" Number of fermionic operators: ", self.n_ops)

        n = self.n_spin_orb

        pool_vec = np.zeros((4 ** n,))

        for i in self.fermi_ops:
            pauli = parity(i, self.n_spin_orb)
            for line in pauli.terms:
                line = str(line)
                Bin = np.zeros((2 * n,), dtype=int)
                X_pat_1 = re.compile("(\d{,2}), 'X'")
                X_1 = X_pat_1.findall(line)
                if X_1:
                    for i in X_1:
                        k = int(i)
                        Bin[n + k] = 1
                Y_pat_1 = re.compile("(\d{,2}), 'Y'")
                Y_1 = Y_pat_1.findall(line)
                if Y_1:
                    for i in Y_1:
                        k = int(i)
                        Bin[n + k] = 1
                        Bin[k] = 1
                Z_pat_1 = re.compile("(\d{,2}), 'Z'")
                Z_1 = Z_pat_1.findall(line)
                if Z_1:
                    for i in Z_1:
                        k = int(i)
                        Bin[k] = 1
                # print(Bin)
                index = int("".join(str(x) for x in Bin), 2)
                # print("index", index)

                pool_vec[index] = int(1)

        nz = np.nonzero(pool_vec)[0]

        print("pauli pool size:", len(pool_vec[nz]))

        self.fermi_ops = []

        m = 2*n

        for i in nz:
            p = int(i)
            bi = bin(p)
            b_string = [int(j) for j in bi[2:].zfill(m)]
            pauli_string = ''
            for k in range(n):
                if b_string[k] == 0:
                    if b_string[k + n] == 1:
                        pauli_string += 'X%d ' % k
                if b_string[k] == 1:
                    if b_string[k + n] == 1:
                        pauli_string += 'Y%d ' % k
                    #if b_string[k + n] == 0:
                    #    pauli_string += 'Z%d ' % k

            A = QubitOperator(pauli_string, 0 + 1j)
            print("Pauli:", pauli_string)
            self.fermi_ops.append(A)

        self.n_ops = len(self.fermi_ops)

        print(" Number of pauli operators: ", self.n_ops)

        return #get individual pauli string from singlet GSD up down ....
